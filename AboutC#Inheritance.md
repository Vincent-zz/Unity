## 关于：*继承、重写、多态、抽象、接口* 

**类的继承关系**本是一种从属包含关系，但如果从父子关系的角度记忆可能会更加形象： 

老郑有三个儿子：郑大、郑二、郑三。每个人都有着自己的生活经验（数据成员）和生活技能（成员函数）。 

老郑的生活经验和生活技能有三种类别：外人知道了也无妨的日常事务（`public`）；只能告诉子孙的传家秘术（`protected`）；老郑打算带进坟里的人生秘密（`private`）。宗旨是，能不告诉外人的尽量不告诉外人（尽量隐藏类信息）。 

老郑对儿子毫不偏心，三个儿子都从老郑这里继承了前两类生活经验和生活技能，并且有自己的新知识、新技能。 

**new重写**：郑大觉得老爹用开水泡泡面的生活技能不适合他这个新时代青年，于是打算用他自己的方法来替代。 

```C#
public class 老郑
{
    protected void 泡面()
    {
        ...//开水泡面 
    }
}
public class 郑大 : 老郑
{
    new void 泡面()
    {
        ...//板蓝根泡面
    }
}
``` 

从此，郑大都用自己的方式泡面（`郑大.泡面();`执行结果是一碗板蓝根泡面），但是老爹开水泡泡面的方法并没有被真正推翻（并没有实现多态，下文再讲）。 

**虚函数重写与多态**：老郑一直对自己电脑上用的某数字浏览器很不满意，于是告诉儿子，如果有其他的浏览器就把这个换掉。 

```C#
public class 老郑
{
    public virtual void 上网()
    {
        ...//打开某数字浏览器
    }
}
```  

后来郑二把自己家的浏览器改成了Edge，郑三改成了Chrome。 

```C#
public class 郑二 : 老郑
{
    public override void 上网()
    {
        ...//打开Edge浏览器
    }
}
``` 

于是老爹果断抛弃某数字，在郑二家就用Edge，在郑三家就用Chrome。郑大作为新时代青年，竟能忍受某数字浏览器，于是没有改变老爹原本的上网方式，在家里和老郑继续着辣眼睛的上网体验。 

```C#
public class 郑大 : 老郑
{
    //啥也不干
}
``` 

（老郑在三个儿子家用不同浏览器，实现了多态，下文再细说） 

**抽象类**：老郑觉得自己过于瘦弱，不好意思出门(`public abstract class 老郑 {...}`抽象类无法实例化)，但自己年事已高练不动了，于是立下家规，儿子们必须天天健身，不练成猛男不许出门 

```C#
public abstract class 老郑 
{
    public abstract void 成为猛男();
}
``` 

郑二郑三经过努力分别练成了施瓦辛格和史泰龙，成功走出出家门（可实例化） 

```C#
public class 郑二 : 老郑
{
    public override void 成为猛男()
    {
        ...//训练计划
        ...//饮食计划
    }
}
```

郑大觉得做个肥宅也是相当快乐的，于是把家规告诉自己儿子之后又躺回了床上（仍为抽象类，无法实例化）。 

```C#
public abstract class 郑大 : 老郑 
{
    //啥也不干
}
public class 郑大儿子 : 郑大
{
    public override void 成为猛男()
    {
        ...//自此，郑大儿子成为了猛男，可出家门（实例化）
    }
}
``` 

\* 死规定（？）：虚函数与抽象函数在父类与子类都必须是public 

\* 虚函数重写与new重写的区别： 

```C#
    //按上文的例子

    老郑 Z1 = new 郑大();
    老郑 Z2 = new 郑二();
    老郑 Z3 = new 郑三();
    //虚函数实现了多态（虚函数意在始终以子类的函数为准）
    Z1.上网();//某数字
    Z2.上网();//Edge
    Z3.上网();//Chrome
    //重写不能实现多态
    Z1.泡面();//开水泡面
    郑大 Z1_ = new 郑大();
    Z1_.泡面();//板蓝根泡面
``` 

\* 关于base（重写时调用父类函数）： 

```C#
public class 老郑 : Monobehaviour
{
    protected void Start()
    {
        刷牙();
        洗脸();
    }
    protected void 刷牙()
    {
        ...//实现刷牙
    }
    protected void 洗脸()
    {
        ...//实现洗脸
    }
}
public class 郑大 : 老郑
{
    private bool 困;
    new void Start()
    {
        while(困)
        {
            再睡五分钟(ref 困);
        }
        base.Start();
    }
    new void 刷牙()
    {
        //不刷牙
    }
    new void 洗脸()
    {
        //不洗脸
    }
    ...
}
``` 

郑大挂载在Unity场景中的某物体上，开始游戏，Mono魔法会调用郑大的`Start()`函数。郑大的小心思是：表面上通过`base.Start()`调用了老爹起床后做的事，实际上自己偷偷重写了洗脸刷牙的函数，这样就可以不洗脸刷牙还不被老爹知道了！可惜老郑魔高一丈，因为`base.Start()`在调用函数时实际上优先调用父类的函数，除非老郑将洗脸刷牙设为虚函数让郑大override，郑大只能乖乖刷牙洗脸。 

**接口**：完全抽象类的简单表示，平行宇宙里有一个fw老郑，啥事都不会，全留给儿子实现。 

```C#
interface 老郑
{
    //无需abstract关键字，访问修饰符public也可直接省略
    void 等待实现1();
    int 等待实现2();
    ...
}
public class 郑大 : 老郑
{
    //无需override关键字
    public void 等待实现1()
    {
        ...//实现1
    }
    public int 等待实现2()
    {
        ...//实现2
    }
    ...
}
``` 

---
[Back to Notes](https://github.com/Vincent-zz/Unity/blob/main/UnityNotes.md)